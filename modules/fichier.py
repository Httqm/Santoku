#!/usr/bin/env python

# Copyright (C) 2012 Matthieu FOURNET, fournet.matthieu@gmail.com
#
# This file is part of Santoku.
#
# Santoku is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Santoku is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Santoku.  If not, see <http://www.gnu.org/licenses/>
#


import re
from modules import config
from modules import debug

debug = debug.Debug()


########################################## ##########################################################
# any file
########################################## ##########################################################
class Fichier(object):

    def __init__(self, params):
        self._name = params['name']

    """
    def _readWholeContent(self):
        try:
            theFile         = open (self._name,'r')
            fileContents    = theFile.read()
            theFile.close()
            return fileContents
        except:
            debug.die({ 'exitMessage' : 'File "' + self._name + '" not found'})
    """

    def _makeHeaderWithWarningMessage(self):
        """ Generate a basic header for output files showing generation date + a 'do not modify manually' warning """
        import datetime
        now = datetime.datetime.now()
        return "########################################## ##########################################################\n" \
            + "# " + self._name + "\n# Generated by Santoku on " + now.strftime("%Y/%m/%d %H:%M") + "\n" \
            + "# Don't edit manually or changes might be overwritten !\n" \
            + "########################################## ##########################################################\n\n"


    def write(self, data):
        try:
            outFile = open(self._name,'w')
            outFile.write(self._makeHeaderWithWarningMessage())
            outFile.write(data)
            outFile.close()
        except IOError as e :
            debug.die({ 'exitMessage' : 'Can not write results to "' + self._name + '" : ' + e.strerror})



########################################## ##########################################################
# an input CSV file
########################################## ##########################################################
class FileCsv(object):

    def __init__(self, params):
        self._name      = params['name']
        self._fs        = config.csvFileFs
        self.contents   = self._loadContentIntoDict()


    def _loadContentIntoDict(self):
        """ Load data from CSV file into a dictionary """
        self._getColumnNumbers()
        return self._readCsvDataIgnoringHeaders()


    def _getColumnNumbers(self):
        """
        Read the header of the CSV file, then builds a dictionary
        matching the column number with its header (as text)
        """
        try:
            inputFile   = open(self._name,'r')
            self.header = inputFile.readline()
            inputFile.close()
        except IOError:
            debug.die({ 'exitMessage' : 'Source CSV file "' + self._name + '" declared in "' + config.configFile + '" not found.'})

        self._columNumberToText     = {}
#        self._columnTextToNumber    = {}
        champs          = self.header.split(self._fs)
        columnNumber    = 0

        for champ in champs:
            tmp                                     = champ.strip('"')
            self._columNumberToText[columnNumber]   = tmp
#            self._columnTextToNumber[tmp]            = columnNumber	# TODO : useless ?
            columnNumber += 1


    def _readCsvDataIgnoringHeaders(self):
        import fileinput
        csvData = {}
        lineNb  = -1    # hack so that the 1st host has the ID '1'
        for line in fileinput.input([self._name]):
            lineNb += 1
            if(lineNb == 0):
                continue    # skip CSV headers line

            ligne       = line.split(self._fs)
            hostFields  = {}

            for clefs in self._columNumberToText.keys():
                hostFields[self._columNumberToText[clefs]] = ligne[clefs].strip('"')

            csvData[lineNb] = hostFields

        return csvData


    def getHeader(self):
        """ Return the header of the CSV file as a list of fields."""
        return self.header.replace('"', '').split(self._fs)


############################################ ##########################################################
### .ini files (input)
############################################ ##########################################################
class FileIni(object):

    def __init__(self, params):
        self._name = params['name']


    # was getData()
    def loadData(self):
        self._checkFileIsThere()
        data           = {}
        sectionType    = None
        for line in self._iniFile:
            if self._lineIsAComment(line) or self._lineIsBlank(line):
                continue

            if self._lineIsASectionTitle(line):
                # found a section. Detecting which kind of section it is
                sectionType = self._match.group(1)   # PATTERN|VARIABLE2TAG|COMMAND
                if sectionType == config.iniPatternString or sectionType == config.iniCommandString :
                    data[sectionType] = ''
                """
                elif(sectionType == config.iniVarToTagString):
                    data[sectionType]	= {}
                """

            else:
                # loading data from section
                if sectionType == config.iniPatternString or sectionType == config.iniCommandString :
                    data[sectionType] += line
                """
                elif(sectionType == config.iniVarToTagString) :
                    line = self.removeWhitespaces(line)
                    self.checkLineMatchesFormat(line)
                    match = re.search('^(.+)' + config.iniVarToTagStanzaFs + '(.+)$', line)
                    if(match):
                        data[sectionType][match.group(2)] = match.group(1)
                """
        return data


    def _checkFileIsThere(self):
        try:
            self._iniFile = open(self._name, 'r')
        except IOError:
            debug.die({ 'exitMessage' : 'Expected file "' + self._name + '" not found.'})




    def _lineIsAComment(self, line):
        match = re.search('^#', line)
        if(match):
            return 1
        else:
            return 0


    def _lineIsBlank(self, line):
        match = re.search('^\n$', line)
        if(match):
            return 1
        else:
            return 0


    def _lineIsASectionTitle(self, line):
        self._match = re.search('\[(.+)\]', line)
        return 1 if self._match else 0
