#!/usr/bin/env python

# Copyright (C) 2012 Matthieu FOURNET, fournet.matthieu@gmail.com
#
# This file is part of Santoku.
#
# Santoku is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Santoku is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Santoku.  If not, see <http://www.gnu.org/licenses/>
#


import re
from modules import config
from modules import debug

debug = debug.Debug()


########################################## ##########################################################
# any file
########################################## ##########################################################
class Fichier(object):

    def __init__(self, params):
        self.name = params['name']


    def _makeHeaderWithWarningMessage(self):
        """ Generate a basic header for output files showing generation date + a 'do not modify manually' warning """
        import datetime
        now = datetime.datetime.now()
        return "########################################## ##########################################################\n" \
            + "# " + self.name + "\n# Generated by Santoku on " + now.strftime("%Y/%m/%d %H:%M") + "\n" \
            + "# Don't edit manually or changes might be overwritten !\n" \
            + "########################################## ##########################################################\n\n"


    def write(self, data):
        try:
            outFile = open(self.name, 'w')
            outFile.write(self._makeHeaderWithWarningMessage())
            outFile.write(data)
            outFile.close()
        except IOError as e :
            debug.die({'exitMessage': 'Can not write results to "' + self.name + '" : ' + e.strerror})



########################################## ##########################################################
# an input CSV file
########################################## ##########################################################
class FileCsv(object):

    def __init__(self, params):
        self.name       = params['name']
        self._fs        = config.csvFileFs
        self.contents   = self._loadContentIntoDict()


    def _loadContentIntoDict(self):
        """ Load data from CSV file into a dictionary """
        self._getColumnNumbers()
        return self._readCsvDataIgnoringHeaders()


    def _getColumnNumbers(self):
        """
        Read the header of the CSV file, then builds a dictionary
        matching the column number with its header (as text)
        """
        try:
            inputFile   = open(self.name, 'r')
            self.header = inputFile.readline()
            inputFile.close()
        except IOError:
            debug.die({'exitMessage': 'Source CSV file "' + self.name + '" declared in "' + config.configFile + '" not found.'})

        self._columNumberToText = {}
        champs                  = self.header.split(self._fs)
        columnNumber            = 0

        for champ in champs:
            tmp = champ.strip('"')
            self._columNumberToText[columnNumber] = tmp
            columnNumber += 1


    def _readCsvDataIgnoringHeaders(self):
        import fileinput
        csvData = {}
        lineNb  = -1    # hack so that the 1st host has the ID '1'
        for line in fileinput.input([self.name]):
            lineNb += 1
            if(lineNb == 0):
                continue    # skip CSV headers line

            ligne       = line.split(self._fs)
            hostFields  = {}

            for clefs in self._columNumberToText.keys():
                hostFields[self._columNumberToText[clefs]] = ligne[clefs].strip('"')

            csvData[lineNb] = hostFields

        return csvData


    def getHeader(self):
        """ Return the header of the CSV file as a list of fields."""
        return self.header.replace('"', '').split(self._fs)



########################################## ##########################################################
# .ini files (input)
########################################## ##########################################################
class FileIni(object):

    def __init__(self, params):
        self.name = params['name']


    def loadData(self):
        self._checkFileIsThere()
        self._data  = {}
        sectionType = None
        for line in self._iniFile:
            if self._lineIsAComment(line) or self._lineIsBlank(line):
                continue

            if self._lineIsASectionTitle(line):
                # found a section. Detecting which kind of section it is
                sectionType = self._match.group(1)   # PATTERN|COMMAND
                if sectionType == config.iniPatternString or sectionType == config.iniCommandString :
                    self._data[sectionType] = ''
            else:
                # loading data from section
                if sectionType == config.iniPatternString or sectionType == config.iniCommandString :
                    self._data[sectionType] += line
        return self._data


    def _checkFileIsThere(self):
        try:
            self._iniFile = open(self.name, 'r')
        except IOError:
            debug.die({'exitMessage': 'Expected file "' + self.name + '" not found.'})


    def _lineIsAComment(self, line):
        match = re.search('^#', line)
        return 1 if match else 0


    def _lineIsBlank(self, line):
        match = re.search('^\n$', line)
        return 1 if match else 0


    def _lineIsASectionTitle(self, line):
        self._match = re.search('\[(.+)\]', line)
        return 1 if self._match else 0


    def searchSection(self, sectionTitle):
        try:
            self._data[sectionTitle]
        except KeyError:
            debug.die({'exitMessage': 'No "' + sectionTitle + '" section found in "' + self.name + '"'})
